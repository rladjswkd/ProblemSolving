### 매개 변수 탐색?

```
5 3
1 3 5 6 10
```

티셔츠 만드는 비용을 매개 변수 `P`로 활용. 티셔츠 만드는 비용이 `P`보다 작거나 `P`와 같아야 한 개의 조를 이룰 수 있다.

`P`는 0 ~ 9 사이의 값

`P` = 9 → 1개 조

`P` = 4 → [1,3,5], [6,10] 2개 조

`P` = 2 → [1,3], [5,6], [10] 3개 조

    - 3 - 1 + 6 - 5 + 10 - 10 = 3

가능한 로직으로 보인다.

아 만약 `P` = 2에서 조건을 만족하면 그보다 큰 값에서도 만족하는지 확인할 필요가 있어 보인다.

`P` = 3 → [1,3], [5,6], [10]. 똑같네

> 시간 복잡도

`P`는 최대 $10^9 - 1$ 이므로 대략 $10^9$라 치고, `P`에 대한 이분 탐색에서 $log_2(10^9)$은 대략 30.

N은 최대 300,000 이며, K가 300,000일 때 최저 1개 조부터 최대 300,000개의 이분 탐색을 수행해야 하므로 대략 150,000개의 이분 탐색이 필요하다 하자.

따라서 $30 × 150000 × log_2{300000}$.

이렇게 계산하면 그 결괏값이 대략 8200만이므로 가능하지 않을까..?

확실한 게 아니긴 하다.

### 그리디?

```
5 3
1 3 5 6 10
```

원생 키의 최솟값이 1이고 최댓값이 10이다.

둘의 차이는 9이고, 이를 k = 3개의 조로 균등하게 나눌 수 있다 하면 각 조마다 3의 키 차이를 할당할 수 있다.

1부터 조를 편성할 때, 5까지를 하나의 조로 편성하면 이 조의 키 차이는 4가 된다. 5를 빼고 [1, 3]을 하나의 조로 편성한다.

5부터 조를 편성할 때, 10까지를 하나의 조로 편성하면 이 조의 키 차이는 5가 된다. 10을 빼고 [5, 6]을 하나의 조로 편성한다.

10부터 조를 편성할 때, 뒤에 남은 학생이 없으므로 10 한명으로 조를 편성한다.

> 맞나?

```
2 2
1 1000000000
```

최대 키 차이: 999999999

각 조마다 할당할 키 차이 49999999.5

[1], [1000000000]

성립.

```
5 3
1 7 8 9 10
```

[1], [7,8,9], [10] 또는 [1], [7,8], [9,10] 또는 [1], [7], [8,9,10]이 최선이지만 각 조마다 3씩 키 차이를 할당하면 [1], [7,8,9,10]로 조가 편성된다.

```
5 3
1 5 7 8 9
```

[1], [5], [7,8,9]가 최선이지만, 각 조마다 2씩 키 차이를 할당하면 [1], [5,7], [8,9]로 조가 편성된다.

아닌듯.

> 키 차이를 활용

```
5 3
1 3 5 6 10
```

인접한 원생들 사이의 키 차이는 2 2 1 4다.

모든 원생을 각각 하나의 조로 편성하면 티셔츠를 만드는 비용이 0일 것이다.

그러나, 원생들을 2개의 조로 나눠야 한다고 할 때, 어떤 두 원생 사이를 기준으로 조를 나누는 게 최선일까?

6과 10 사이를 나눠 [1,3,5,6]과 [10]으로 조를 편성하는 게 최선이고, 이 때 티셔츠를 만드는 비용은 6 - 1 = 5다.

이는 인접한 원생들 사이의 키 차이 배열에서 4를 제거하고 남은 2, 2, 1을 더한 값과 같다.

즉, 인접한 원생들 사이의 키 차이 배열에서 가장 큰 값을 제거해야 한다.

그럼 조를 3개로 나눠야 할 땐?

그 다음으로 큰 값을 제거하면 될 것이다.

그 다음으로 큰 값은 2이지만, 2개가 있다.

[1], [3,5,6], [10]과 [1,3], [5,6], [10]으로 조 편성이 가능하며, 두 경우 다 티셔츠를 만드는 비용은 3이다.

조가 2개면 가장 큰 값 1개를 제거하고, 조가 3개면 가장 큰 값 2개를 제거하고, ... 조가 k개면 가장 큰 값 k - 1개를 제거하면 된다.

```java
import java.io.IOException;
import java.util.Arrays;

public class Main {
	private static int n, k;
	private static int[] diffs;

	private static int read() throws IOException {
		int n = System.in.read() & 15, c;

		while (48 <= (c = System.in.read()) && c <= 57)
			n = (n << 3) + (n << 1) + (c & 15);
		return n;
	}

	public static void main(String[] args) throws IOException {
		int l, r, last, res = 0;

		n = read();
		k = read();
		diffs = new int[n - 1];
		l = read();
		for (int i = 1; i < n; i++) {
			r = read();
			diffs[i - 1] = r - l;
			l = r;
		}
		Arrays.sort(diffs);
		last = n - 1 - k + 1;
		for (int i = 0; i < last; i++)
			res += diffs[i];
		System.out.println(res);
	}
}
```
