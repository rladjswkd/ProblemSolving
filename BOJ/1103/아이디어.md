사이클이 존재하면 -1, 그렇지 않으면 최대 이동 횟수 출력

BFS로 풀 수 있을까? 이미 방문한 곳에 다시 방문하게 되는 경우 사이클이 존재한다?

그렇지 않다.

```
2 1 3 1
1 1 1 1
2 1 2 1
```

위 보드에서 3인 칸은 (0, 0)의 2에서 바로 방문할 수 있다.

이후 (0, 0), (2, 0), (2, 2) 를 거쳐오는 경로가 다시 3인 칸을 방문하는데, 그렇다 해도 사이클이 생기진 않는다.

입력의 크기가 작으므로 DFS로 풀 수 있을 것 같다.

경로 탐색하며 방문 처리 -> 동전이 구멍에 빠지거나 보드를 벗어나면 결과 변수 업데이트하고 리턴. 또는 방문한 칸을 다시 방문한 경우 DFS를 종료하고 -1을 출력 -> 방문 처리한 칸들 다시 미방문처리하고 그 다음 DFS 경로 탐색

---

> 어떤 칸 (x, y)에 방문하는 경로가 여러 개일 수 있다.

(x, y)에서 출발해 최대로 이동할 수 있는 횟수는 모두 같으므로 중복으로 연산하지 않는 것이 좋다.

2차원 int 배열을 사용해 방문 여부 확인까지 동시에 처리하자.

이를 위해 방문 처리한 칸들을 다시 미방문 처리하지 않아야 한다.

단, 모든 칸들은 세 가지 상태를 가질 수 있어야 한다.

1. 미방문 상태 → 0
2. 방문했지만 아직 이 칸에서 출발했을 때 최대 이동 횟수가 얼마인지 연산하지 않은 상태 → 1
3. 방문했고 최대 이동 횟수가 얼마인지 연산한 상태 → 2 이상의 값

DFS를 수행하면서 배열의 값이 1인 칸을 다시 방문하면 사이클이 존재하는 것이다.

DFS를 수행하면서 배열의 값이 2 이상인 칸을 방문한 경우 DFS를 더 수행하지 않고 그냥 배열의 값을 반환하면 된다.
