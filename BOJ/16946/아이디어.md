- 모든 1인 칸에 대해 BFS?

1000 x 1000 행렬에서 첫 번째 행의 모든 값이 1이고, 나머지 모든 행의 모든 값이 0일 때

첫 번째 행의 모든 칸에 대해 BFS를 수행해야 하고, 이 BFS는 총 900 \* 1000 개의 칸을 방문한다.  
-> 1000 \* 900 \* 1000 = 9억 -> 시간 초과이지 않을까... 시간 제한이 2초여도 조금 애매하다.

- 오히려 반대로 0인 모든 칸에서 BFS를 돌리고 BFS 과정에 만나는 1인 칸들을 별도로 저장 후, BFS 결과 방문한 0인 칸의 개수를 세어 별도로 저장한 1인 칸들에 그 값 + 1을 반영하기?

-> 0인 칸들에 대해 중복적인 BFS 연산을 제거할 수 있다.

000
101
000

이런 구조에서 두 1인 칸은 3번 방문하게 된다.
이들 중 한 번만 처리해야 올바른 결과를 얻을 수 있다.

그렇다고 1인 칸들을 한 번 방문할 때 무조건 방문 처리를 한다면 다음과 같은 문제가 생긴다.

000
111
000

여기서 각 1들은 (0, 0)에서부터 시작한 BFS가 (0, 1), (0, 2)를 지나며 모두 방문처리가 된다.
따라서 (2, 0)에서 시작한 BFS가 방문할 수 없게 돼, 올바른 결과가 나오지 못한다.

따라서 각 BFS가 종료될 때, 해당 BFS 경로에서 방문처리한 1인 칸들을 다시 방문하지 않음으로 처리해줘야 한다.

> 1인 칸에서 벽을 부숴 0인 칸으로 만들었을 때, 자기 자신 또한 방문할 수 있는 칸으로 처리하는 것을 매 BFS마다 처리해주면 안된다.

각 BFS에선 방문할 수 있는 0인 칸들만 세고, 나중에 출력할 때 0이 아닌 칸이라면 + 1을 해서 출력하자.
