
/*
 * 백트래킹?
 * BFS?
 * 길이가 최대 100이고, 시작은 1 ~ 9가 가능하다.
 * -> 0, 9를 제외한 나머지 수는 그 다음 자리로 선택할 수 있는 수가 2가지 -> 2^99(0은 1, 9는 8만 선택할 수 있으므로
 * 실제론 이보다 적겠지만 그래도 무조건 시간 초과)
 * 
 * DP?
 * 
 * 길이 0 ~ 9 : 0
 * 길이 10 : 9876543210
 * 길이 11 : 89876543210, 98765432101, 10123456789
 * 길이 12 : 길이 10 짜리에 가능한 모든 연속하는 두 자리 내림차순의 수를 결합한 경우의 수 + 길이 11짜리 앞 뒤에 숫자 하나 이어붙인 수 - 둘의 중복 흠....?
 * 
 * 이번에 0 ~ 9 중 어떤 자릿수를 선택하든, 그 이전까지의 수가 어떤 자릿수들을 선택해왔는지가 반영되어야 한다.
 * 문제는 자릿수로 i를 선택할 때, 선택할 수 있는 이전의 수는 자릿수로 i - 1을 선택한 수와 i + 1을 선택한 수 두 개가 있다는 것이다.
 * 이를 계속해서 누적해나가면 백트래킹과 다를 게 없다..
 * 그렇다고 둘 중 하나만 선택하는 건 올바른 방식이 아니다.
 * 
 * ---
 * 
 * 백트래킹은 시간 초과. 그리디로 풀 여지가 있나? 없다.
 * 그럼 DP인데..
 * 
 * 0 ~ 9를 고려하지 않고 그냥 계단 수인지 아닌지 그 여부만을 dp로 구하는 방식
 * 행: 선택한 자릿수의 개수
 * 열: 0 ~ 9 까지의 자릿수
 * 
 * 			0		1		2		3		4		5		6		7		8		9
 * 1		0		1		1		1		1		1		1		1		1		1
 * 2		1		1		2		2		2		2		2		2		2		1
 * 3		1		3		3		4		4		4		4		4		4		2
 * 4		3		4		7		7		8		8		8		8		8		4
 * 5		4		11	11	15	15	16	16	16	16	8
 * ...
 * 
 * 문제는, i행 j열의 각 숫자에 대해 0 ~ 9의 자릿수 중 어느 숫자들을 선택해왔는지를 추적해야 한다는 것이다.
 * 단순히 다 추적하면 백트래킹과 다를 바 없고 메모리 초과로 프로그램이 터질 것이다.
 * 
 * 질문 게시판 첫 번째 글 참고.
 * 
 * 3차원 dp 배열을 활용
 * 1차원은 입력으로 받을 길이 N.
 * 2차원은 0 ~ 9
 * 3차원은 1 << 0 ~ 1 << 9 | 1 << 8 | ... | 1 << 0 까지의 조합을 모두 수용할 수 있는 크기 1024
 * 
 * ---
 * 
 * 3차원을 조금 다르게 사용하는 방법
 * 결국 0 ~ 9를 모두 포함하려면 시작 숫자가 뭐든 간에 0까지 한 번 갔다가 9까지 한 번 가야 한다.
 * -> 0에 도달하면 1 9에 도달하면 2, 그 외엔 0 -> 0 ~ 3의 값을 활용하므로 3차원의 크기는 4면 된다.
 * 
 * 
 * 
 */
import java.io.IOException;

public class Main {
	private static int n, res = 0;
	private static long[][][] dp;

	private static int readInt() throws IOException {
		int n = System.in.read() & 15, cur;

		while (48 <= (cur = System.in.read()) && cur <= 57)
			n = (n << 3) + (n << 1) + (cur & 15);
		return n;
	}

	public static void main(String[] args) throws IOException {
		n = readInt();
		dp = new long[n][10][1024];
		for (int j = 1; j < 10; j++)
			dp[0][j][1 << j] = 1;
		for (int i = 1; i < n; i++) {
			for (int k = 0; k < 1024; k++)
				dp[i][0][k | 1 << 0] = (dp[i][0][k | 1 << 0] + dp[i - 1][1][k]) % 1_000_000_000;
			for (int j = 1; j < 9; j++)
				for (int k = 0; k < 1024; k++)
					dp[i][j][k | 1 << j] = (dp[i][j][k | 1 << j] + dp[i - 1][j - 1][k] + dp[i - 1][j + 1][k]) % 1_000_000_000;
			for (int k = 0; k < 1024; k++)
				dp[i][9][k | 1 << 9] = (dp[i][9][k | 1 << 9] + dp[i - 1][8][k]) % 1_000_000_000;
		}
		for (int j = 0; j < 10; j++)
			res = (int) ((res + dp[n - 1][j][1023]) % 1_000_000_000);
		System.out.println(res);
	}
}