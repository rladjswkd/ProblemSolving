n = 1

```
(1, 1)
1
```

n = 2

```
(1, 1) (1, 2)
(2, 1)
3
```

n = 3

```
(1, 1) (1, 2) (1, 3)
(2, 1) (2, 3)
(3, 1)
6
```

n = 4

```
(1, 1) (1, 2) (1, 3) (1, 4)
(2, 1) (2, 3)
(3, 1) (3, 4)
(4, 1)
9
```

n = 5

```
(1, 1) (1, 2) (1, 3) (1, 4) (1, 5)
(2, 1) (2, 3) (2, 5)
(3, 1) (3, 4)
(4, 1) (4, 5)
(5, 1)
13
```

n = 6

```
(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6)
(2, 1) (2, 3) (2, 5)
(3, 1) (3, 4)
(4, 1) (4, 5)
(5, 1) (5, 6)
(6, 1)
16
```

n = 7

```
(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7)
(2, 1) (2, 3) (2, 5) (2, 7)
(3, 1) (3, 4) (3, 7)
(4, 1) (4, 5)
(5, 1) (5, 6)
(6, 1) (6, 7)
(7, 1)
21
```

n = 8

```
(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8)
(2, 1) (2, 3) (2, 5) (2, 7)
(3, 1) (3, 4) (3, 7)
(4, 1) (4, 5)
(5, 1) (5, 6)
(6, 1) (6, 7)
(7, 1) (7, 8)
(8, 1)
24
```

n = 9

```

(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8) (1, 9)
(2, 1) (2, 3) (2, 5) (2, 7) (2, 9)
(3, 1) (3, 4) (3, 7)
(4, 1) (4, 5) (4, 9)
(5, 1) (5, 6)
(6, 1) (6, 7)
(7, 1) (7, 8)
(8, 1) (8, 9)
(9, 1)
29
```

n = 10

```

(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8) (1, 9) (1, 10)
(2, 1) (2, 3) (2, 5) (2, 7) (2, 9)
(3, 1) (3, 4) (3, 7) (3, 10)
(4, 1) (4, 5) (4, 9)
(5, 1) (5, 6)
(6, 1) (6, 7)
(7, 1) (7, 8)
(8, 1) (8, 9)
(9, 1) (9, 10)
(10, 1)
33
```

n = 11

```

(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8) (1, 9) (1, 10) (1, 11)
(2, 1) (2, 3) (2, 5) (2, 7) (2, 9) (2, 11)
(3, 1) (3, 4) (3, 7) (3, 10)
(4, 1) (4, 5) (4, 9)
(5, 1) (5, 6) (5, 11)
(6, 1) (6, 7)
(7, 1) (7, 8)
(8, 1) (8, 9)
(9, 1) (9, 10)
(10, 1) (10, 11)
(11, 1)
38
```

n = 12

```

(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8) (1, 9) (1, 10) (1, 11) (1, 12)
(2, 1) (2, 3) (2, 5) (2, 7) (2, 9) (2, 11)
(3, 1) (3, 4) (3, 7) (3, 10)
(4, 1) (4, 5) (4, 9)
(5, 1) (5, 6) (5, 11)
(6, 1) (6, 7)
(7, 1) (7, 8)
(8, 1) (8, 9)
(9, 1) (9, 10)
(10, 1) (10, 11)
(11, 1) (11, 12)
(12, 1)
41
```

모든 쌍 (x, y)의 y에서 1을 빼면 y는 n보다 작은 x의 배수들이 된다.

n보다 작은 1의 배수의 개수 + 1(y - 1 == 0을 포함)  
n보다 작은 2의 배수의 개수 + 1  
n보다 작은 3의 배수의 개수 + 1  
...  
n보다 작은 n - 1의 배수의 개수 + 1

> 그냥 x = 1부터 x = n까지 반복문 돌면서 (n - 1) / x + 1을 누적하면 답은 나온다.

단, 입력값이 최대 10억이므로 시간 초과.

```java
import java.io.IOException;

public class Main {
	private static int read() throws IOException {
		int n = System.in.read() & 15, c;

		while (48 <= (c = System.in.read()) && c <= 57)
			n = (n << 3) + (n << 1) + (c & 15);
		return n;
	}

	public static void main(String[] args) throws IOException {
		int n = read();
		long res = 0;

		for (int i = 1; i <= n; i++)
			res += (n - 1) / i + 1;
		System.out.println(res);
	}
}
```

> n = 3 부터는 x = (n - 1) / 2 까지만 n보다 작은 x의 배수의 개수가 3개 이상이다.

x > (n - 1) / 2 일땐, 무조건 n보다 작은 x의 배수는 2개이며, x = n일 땐 1개이다.

시간 복잡도를 절반으로 줄일 순 있지만 그래도 5억개 언저리의 연산이 필요하므로 시간 초과.

```java
import java.io.IOException;

public class Main {
	private static int read() throws IOException {
		int n = System.in.read() & 15, c;

		while (48 <= (c = System.in.read()) && c <= 57)
			n = (n << 3) + (n << 1) + (c & 15);
		return n;
	}

	public static void main(String[] args) throws IOException {
		int n = read(), boundary;
		long res = 0;

		if (n < 3)
			System.out.println((n << 1) - 1);
		else {
			boundary = (n - 1) >>> 1;
			for (int i = 1; i <= boundary; i++)
				res += (n - 1) / i + 1;
			res += 2 * (n - boundary - 1);
			res++;
			System.out.println(res);
		}
	}
}
```

반복문 내부를 보자.

${{n-1}\over{1}} + {{n-1}\over{2}} + {{n-1}\over{3}} + ... + {{n-1}\over{n}} + n$

```
1
2 1
3 2 1
4 2 2 1
5 3 2 2 1
6 3 2 2 2 1
7 4 3 2 2 2 1
8 4 3 2 2 2 2 1
9 5 3 3 2 2 2 2 1
10 5 4 3 2 2 2 2 2 1
11 6 4 3 3 2 2 2 2 2 1
12 6 4 3 3 2 2 2 2 2 2 1
13 7 5 4 3 3 2 2 2 2 2 2 1
14 7 5 4 3 3 2 2 2 2 2 2 2 1
15 8 5 4 3 3 3 2 2 2 2 2 2 2 1
16 8 6 4 4 3 3 2 2 2 2 2 2 2 2 1
17 9 6 5 4 3 3 3 2 2 2 2 2 2 2 2 1
18 9 6 5 4 3 3 3 2 2 2 2 2 2 2 2 2 1
19 10 7 5 4 4 3 3 3 2 2 2 2 2 2 2 2 2 1
20 10 7 5 4 4 3 3 3 2 2 2 2 2 2 2 2 2 2 1
```

[참고](https://ahgus89.github.io/algorithm/Harmonic-Lemma/)
