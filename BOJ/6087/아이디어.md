BFS

최단 거리로 도달할 수 있는 여러 경로들 중 방향 전환이 가장 적은 경로를 선택하면 되는 것 아닌가?

어느 방향을 먼저 고려하는지에 따라 가장 먼저 도달하는 경로가 달라질 수 있다.

따라서 단순히 가장 먼저 도달하는 경로를 거울의 개수를 최소로 사용하는 경로로 선택하면 안된다.

> 거울의 개수를 최소로 사용하는 경로가 최단 경로가 아닐 수 있나?

```
7 . . . . . . .       7 . . . . . . .
6 . . . * . . C       6 . . . * . . C
5 . . . . . . .       5 . . . x x x x/o
4 * * * . * . .       4 * * * x * . o
3 . . . . * . .       3 . . . x * . o
2 . . . . * . .       2 . . . x * . o
1 . C . . * . .       1 . C x x * . o
0 . . . . . . .       0 . o o o o o o
  0 1 2 3 4 5 6         0 1 2 3 4 5 6
```

위 입력에서 `x`를 따라 이동하면 10번째 이동에 6행 6열의 C에 도달한다.

반대로 `o`를 따라 이동하면 12번째 이동에 도달하게 된다.

`x`를 따라 이동하는 경로는 최단 거리로 이동하는 경로지만, 3개의 거울이 필요하다.

`o`를 따라 이동하는 경로는 최단 경로는 아니지만 2개의 거울만 필요하다.

따라서 거울의 개수를 최소로 사용하는 경로가 최단 경로가 아닐 수 있다.

> 각 칸에 도달하기 위해 필요한 최소 거울의 개수를 추적하는 배열을 사용하면 되지 않나?

- C에서 실제 레이저가 뻗어나가듯 상, 하, 좌, 우로 도달할 수 있는 모든 칸을 다 표시하고 큐에 넣는다.

- 큐에 들어있는 칸들에 대해 다시 거울을 사용해 90도 회전한 방향으로 레이저를 쏘고, 거울을 하나 사용했으므로 이를 추적하는 배열에 반영한다.

- 나머지 C에 도달할 때까지 반복

> 편의성을 위해 추적하는 배열 `dist`는 방문하지 않았을 때의 값을 0, 거울 하나로 방문했을 때의 값을 1, ... 거울 n개로 방문했을 때의 값을 n + 1로 한다.

> dist를 사용하지 않고 그냥 visited 배열 + 큐 내에서 같은 dist 값을 갖는 칸들을 한꺼번에 처리하는 방식을 사용해도 될듯

---

> 다른 경로로 인해 현재 레이저가 진행할 칸이 막혀있더라도 그 dist값이 현재 레이저의 dist값보다 크거나 같다면 레이저는 진행할 수 있어야 한다.

```
4 5
C..*
...*
...*
*.**
...C
```
