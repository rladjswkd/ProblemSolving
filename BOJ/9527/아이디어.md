우선, 입력으로 주어진 범위가 $1, 10^{16}$ 이어도 long 타입으로 충분히 표현할 수 있다.
-> $10^{16}$ 개의 숫자 모두 64개의 비트가 1로 채워져있다고 가정하더라도 $64 * 10^{16}$ 은 long 타입으로 표현 가능하다.

$10^{16}$ 을 표현하기 위해선 $log_2{10^{16}}$ 대략 54개의 비트가 필요하다.
0 0  
1 1

1 10  
2 11

1 100  
2 101  
2 110  
3 111

1 1000  
2 1001  
2 1010  
3 1011  
2 1100  
3 1101  
3 1110  
4 1111  
...

1비트짜리 숫자 : 1
2비트짜리 숫자 : (0 ~ 1)의 1의 개수 + 2 또는 2 + 1(2비트짜리 숫자의 각 비트 별 1의 개수)  
3비트짜리 숫자 : (0 ~ 11)의 1의 개수 + 4 또는 4 + 2 + 2  
4비트짜리 숫자 : (0 ~ 111)의 1의 개수 + 8 또는 8 + 4 + 4 + 4  
5비트짜리 숫자 : (0 ~ 1111)의 1의 개수 + 16 또는 16 + 8 + 8 + 8 + 8 a
...

-> 1 + (1 + 2) + (1 + (1 + 2) + 4) + (1 + (1 + 2) + (1 + (1 + 2) + 4) + 8) + ...

> 문제는 주어질 범위가 정확하게 n개의 비트를 사용하는 숫자를 전부 포함하도록 주어지지 않는다는 것이다.

가장 효율적인 방법인지는 모르겠지만 다음과 같이 풀 수 있을 것이다.

0부터 12까지 1의 개수는 다음과 같이 셀 수 있다.

1100 -> 2  
1000 -> 1 \* 2C0 + 2 \* 2C1 + 3 \* 2C2 = 1 + 4 + 3 = 8  
0000 -> 0 \* 3C0 + 1 \* 3C1 + 2 \* 3C2 + 3 \* 3C3 = 3 + 6 + 3 = 12

따라서 12 + 8 + 2 = 22.

마찬가지로 0부터 1까지 1의 개수는 다음과 같이 셀 수 있다.

1 -> 1  
0 -> 0

따라서 1.

22 - 1 = 21. 예제의 답과 같다.

이와 같은 방법을 0부터 B까지의 1의 개수를 세고, 여기서 0부터 A - 1까지의 1의 개수를 세어, 빼면 된다.

1. A와 B를 최상위 비트부터 확인해, 1의 개수를 모두 세고(count) 가장 오른쪽에 있는 값이 1인 비트를 찾는다.
   -> 결과를 저장하는 변수 `res`에 `count`를 반영하기.
1. 가장 오른쪽에 있는 값이 1인 비트를 0으로 만들고, count를 1 감소시킨 다음, 그보다 오른쪽에 있는 비트의 개수(n)를 세어, (count) \* nC0 + (count + 1) \* nC1 + (count + 2) \* nC2 + ... + (count + n) \* nCn을 수행한 결과를 `res`에 반영하기
1. 대상 숫자가 0일 때까지 2번 반복

```text
    0   1   2   3   4   5
0   1   0   0   0   0   0
1   1   1   0   0   0   0
2   1   2   1   0   0   0
3   1   3   3   1   0   0
4   1   4   6   4   1   0
5   1   5   10  10  5   1
```
