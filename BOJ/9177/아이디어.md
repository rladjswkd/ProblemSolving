백트래킹?

포인터로 첫 번째 단어와 두 번째 단어의 현재 인덱스를 추적

```java
import java.io.IOException;

public class Main {
	private static int n, l1, l2, l3;
	private static char[] w1, w2, w3;
	private static StringBuilder sb;
	private static final String DATA_SET = "Data set ", CENTER = ": ", YES = "yes\n", NO = "no\n";
	private static boolean flag;

	private static int read() throws IOException {
		int n = System.in.read() & 15, c;

		while (48 <= (c = System.in.read()) && c <= 57)
			n = (n << 3) + (n << 1) + (c & 15);
		return n;
	}

	private static void solve(int i1, int i2, int i3) {
		if (i3 == l3) {
			flag = true;
			return;
		}
		if (i1 < l1 && w1[i1] == w3[i3])
			solve(i1 + 1, i2, i3 + 1);
		if (!flag && i2 < l2 && w2[i2] == w3[i3])
			solve(i1, i2 + 1, i3 + 1);
	}

	public static void main(String[] args) throws IOException {
		int c;

		n = read();
		w1 = new char[200];
		w2 = new char[200];
		w3 = new char[400];
		sb = new StringBuilder();
		for (int i = 1; i <= n; i++) {
			l1 = l2 = l3 = 0;
			while ('a' <= (c = System.in.read()) && c <= 'z')
				w1[l1++] = (char) c;
			while ('a' <= (c = System.in.read()) && c <= 'z')
				w2[l2++] = (char) c;
			while ('a' <= (c = System.in.read()) && c <= 'z')
				w3[l3++] = (char) c;
			flag = false;
			solve(0, 0, 0);
			sb.append(DATA_SET).append(i).append(CENTER).append(flag ? YES : NO);
		}
		System.out.print(sb.toString());
	}
}
```

> 25% 까지만 통과하고 시간 초과

시간 초과가 나는 이유?

```
rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrt
```

첫 번째 단어의 길이가 200, 두 번째 단어의 길이가 200, 세 번째 단어의 길이가 400

첫 번째 단어와 두 번째 단어가 겹치는 문자가 많으며

세 번째 단어의 마지막 문자가 첫 번째, 두 번째 문자 모두에 존재하지 않는 문자면 무조건 시간 초과긴 하네

> DP

dp[i][j] : 첫 번째 단어의 i번째 문자와 두 번째 단어의 j번째 문자부터 시작해서 세 번째 단어의 (i + j) 번째 문자부터 마지막 문자까지의 부분 문자열을 만들 수 있으면 1, 아니면 -1, 확인하지 않았다면 0.

```java
import java.io.IOException;

public class Main {
	private static int n, l1, l2, l3, idx;
	private static char[] w1, w2, w3;
	private static StringBuilder sb;
	private static final String DATA_SET = "Data set ", CENTER = ": ", YES = "yes\n", NO = "no\n";
	private static int[][][] dp;

	private static int read() throws IOException {
		int n = System.in.read() & 15, c;

		while (48 <= (c = System.in.read()) && c <= 57)
			n = (n << 3) + (n << 1) + (c & 15);
		return n;
	}

	private static int solve(int i1, int i2, int i3) {
		if (i3 == l3)
			return 1;
		if (i1 == l1) {
			while (i2 < l2 && w2[i2] == w3[i3]) {
				i2++;
				i3++;
			}
			return i3 == l3 ? 1 : -1;
		}
		if (i2 == l2) {
			while (i1 < l1 && w1[i1] == w3[i3]) {
				i1++;
				i3++;
			}
			return i3 == l3 ? 1 : -1;
		}
		if ((i1 == l1 && w2[i2] != w3[i3]) || (i2 == l2 && w1[i1] != w2[i3]))
			return -1;
		if (dp[idx][i1][i2] == 1)
			return 1;
		if (dp[idx][i1][i2] == -1)
			return -1;
		if (i1 < l1 && w1[i1] == w3[i3])
			if (solve(i1 + 1, i2, i3 + 1) == 1)
				return dp[idx][i1][i2] = 1;
		if (i2 < l2 && w2[i2] == w3[i3])
			if (solve(i1, i2 + 1, i3 + 1) == 1)
				return dp[idx][i1][i2] = 1;
		return dp[idx][i1][i2] = -1;
	}

	public static void main(String[] args) throws IOException {
		int c;

		n = read();
		w1 = new char[200];
		w2 = new char[200];
		w3 = new char[400];
		// dp가 -1이면 현재 조합으론 세 번째 단어를 만들 수 없음을, 1이면 만들 수 있음을 나타낸다.
		dp = new int[n][200][200];
		sb = new StringBuilder();
		for (int i = 1; i <= n; i++) {
			l1 = l2 = l3 = 0;
			while ('a' <= (c = System.in.read()) && c <= 'z')
				w1[l1++] = (char) c;
			while ('a' <= (c = System.in.read()) && c <= 'z')
				w2[l2++] = (char) c;
			while ('a' <= (c = System.in.read()) && c <= 'z')
				w3[l3++] = (char) c;
			idx = i - 1;
			sb.append(DATA_SET).append(i).append(CENTER).append(solve(0, 0, 0) == 1 ? YES : NO);
		}
		System.out.print(sb.toString());
	}
}
```

> 시간 초과는 나지 않지만 25% 까지 통과하고 틀림

아... 모든 단어는 대문자 또는 소문자로 구성된단다...

```java
import java.io.IOException;

public class Main {
	private static int n, l1, l2, l3;
	private static char[] w1, w2, w3;
	private static StringBuilder sb;
	private static final String DATA_SET = "Data set ", CENTER = ": ", YES = "yes\n", NO = "no\n";
	private static int[][] dp;

	private static int read() throws IOException {
		int n = System.in.read() & 15, c;

		while (48 <= (c = System.in.read()) && c <= 57)
			n = (n << 3) + (n << 1) + (c & 15);
		return n;
	}

	private static int solve(int i1, int i2, int i3) {
		if (i3 == l3)
			return 1;
		if (i1 == l1) {
			while (i2 < l2 && w2[i2] == w3[i3]) {
				i2++;
				i3++;
			}
			return i3 == l3 ? 1 : -1;
		}
		if (i2 == l2) {
			while (i1 < l1 && w1[i1] == w3[i3]) {
				i1++;
				i3++;
			}
			return i3 == l3 ? 1 : -1;
		}
		if (dp[i1][i2] != 0)
			return dp[i1][i2];
		if (i1 < l1 && w1[i1] == w3[i3])
			if (solve(i1 + 1, i2, i3 + 1) == 1)
				return dp[i1][i2] = 1;
		if (i2 < l2 && w2[i2] == w3[i3])
			if (solve(i1, i2 + 1, i3 + 1) == 1)
				return dp[i1][i2] = 1;
		return dp[i1][i2] = -1;
	}

	public static void main(String[] args) throws IOException {
		int c;

		n = read();
		w1 = new char[200];
		w2 = new char[200];
		w3 = new char[400];
		sb = new StringBuilder();
		for (int i = 1; i <= n; i++) {
			l1 = l2 = l3 = 0;
			while ((c = System.in.read()) > 32)
				w1[l1++] = (char) c;
			while ((c = System.in.read()) > 32)
				w2[l2++] = (char) c;
			while ((c = System.in.read()) > 32)
				w3[l3++] = (char) c;
			dp = new int[l1][l2];
			sb.append(DATA_SET).append(i).append(CENTER).append(solve(0, 0, 0) == 1 ? YES : NO);
		}
		System.out.print(sb.toString());
	}
}
```
