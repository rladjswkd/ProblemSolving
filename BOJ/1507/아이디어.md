도로를 하나씩 제거해보는 방법

- 도로를 제거했을 때 주어진 최소 이동 시간 정보가 변함이 없다면 제거해도 되는 도로.
- 그렇지 않다면 제거하면 안되는 도로.

최대 연산 개수를 알아보자.

도로 개수 = 20 \* 19 = 380
플로이드 워셜 연산 개수 = 20^3 = 8000
최소 이동 시간 정보 변화 확인을 위한 연산 개수 = 20 \* 20 = 400

따라서, 380 \* (8000 + 400) 개의 연산이 필요하다.

> 도로를 제거해도 되는지 확인하는 순서에 따라 결과가 달라질 수도 있지 않나?

예를 들어 같은 가중치를 가진 두 도로 a, b가 있을 때, a가 b를 거쳐가는 모든 경로에 대해 b를 대체할 수 있고, 더 많은 경로에 포함된다고 해보자.

순서에 관계 없이 a가 제거될 순 없다. => b보다 더 많은 경로에 포함되므로 a가 제거되면 최소 이동 시간에 변화가 생긴다.

b가 제거되는 건 아무 문제 없다.

그렇다면 같은 가중치를 가진 세 도로 a, b, c가 있을 때 a와 b를 이은 도로가 c를 거쳐가는 모든 경로에서 c를 대체할 수 있다고 해보자.

만약 순서 상 c의 제거 가능 여부를 먼저 확인할 때, c가 제거되면 도로의 개수를 최소로 할 수 없다?

판단할 근거를 찾지 못했다.

---

플로이드 워셜은 via 노드를 거쳐서 end노드로 가는 거리를 고려하는 알고리즘이기 때문에 아래의 19번째 행 20번째 열의 값은 플로이드 워셜을 적용한 후에도 2다.
하지만 입력 자체는 잘못된 것이므로 -1을 반환해야 한다.

```
20
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
```
