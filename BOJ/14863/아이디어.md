### knapsack 문제(DP)

- 시간이 knapsack 문제에서의 무게, 돈이 knapsack 문제에서의 가치가 된다.
- 단, 자전거와 도보의 값이 섞이지 않게 고려해야 한다(예를 들어 500 200 200 100과 같이 주어진 경우, dp[700]에 300이 들어가면 안된다.)

> 따라서 1차원 dp로 풀면 틀린다.

자전거와 도보의 값이 섞일 수 밖에 없기 때문.

값을 범위에 따라 큰 값을 먼저 고려하고, 작은 값을 고려하더라도, 작은 값의 모금액이 더 클 수 있기 때문에 틀린다.

---

> 단순한 knapsack 문제가 아니다.

이전에 선택한 구간들의 시간을 고려하여 남은 시간이 부족하면 모금액이 크더라도 선택할 수 없어야 하기 때문이다.  
예를 들어, 예제 1번을 보자.

```
3 1650
500 200 200 100
800 370 300 120
700 250 300 90
```

단순한 knapsack 문제로 풀면, 두 번째 구간을 고려할 때(편의상 인덱스를 2라고 하자), `dp[2][800]`은 370과 200 + 120 중 큰 값이 선택된다.

하지만, 370은 우리가 선택할 수 있는 값이 아니다.

왜냐하면, 두 번째 구간까지 고려할 때 `dp[2][800]`에는 첫 번째 구간에서 선택한 방법의 소요 시간과 두 번째 구간에서 선택할 방법의 소요 시간이 모두 포함되어야 하기 때문이다.

만약 370을 선택하면, 이는 두 번째 구간에서 800분이 걸리는 방법을 선택한 것이므로 첫 번째 구간에선 0분이 걸리는 방법을 선택해야 한다.

하지만 첫 번째 구간에는 500분과 200분이 걸리는 방법 외엔 없다.

=> 이전 구간까지 선택한 "시간"들을 추적할 수 있어야 한다.

> boolean[][] 배열을 쓰는 것 외에 다른 방법이 있나?

이전 구간까지 선택한 "시간"들이 반영된 값들 외엔 dp를 모두 아주 작은 값으로 설정하면 된다.

어차피 dp의 값을 선택할 때, max 값을 선택하기 때문에 이 것만으로 충분하다.
