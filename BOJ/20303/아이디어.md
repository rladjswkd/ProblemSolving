**분리 집합**

사탕을 뺏은 아이의 친구의 사탕도 뺏어야 하므로 친구의 친구의 친구의... 친구를 모두 하나의 분리 집합에 포함시킨다.  
친구 관계인 아이들을 모두 연결한 후, 그렇게 생성한 여러 분리 집합 중 포함된 아이의 수가 K 미만이면서 가장 많은 사탕을 가진 분리 집합을 찾는다.

> 하나의 분리 집합만 골라야 하는 상황이 아니다. 포함된 노드 수가 총 K개 미만인 여러 개의 분리 집합을 선택할 수 있다.  
> 예제 1번만 봐도 서로 친구인 4-9과 7-8의 사탕을 뺏으면 총 57개의 사탕을 뺏을 수 있으며, 이때 우는 아이의 수는 4명이다.  
> 이때 뺏을 수 있는 사탕의 수가 최대이다.

여기서부턴 DP 배낭 문제로 보인다.

**DP**

분리 집합으로 서로 친구인 아이들을 모아두고 모은 아이들의 사탕의 총 개수를 구했으면, 다음과 같은 기준으로 배낭 문제라고 볼 수 있다.

- 각 분리 집합 = 각 훔칠 물건
- 각 분리 집합에 포함된 아이들의 수 = 각 훔칠 물건의 무게
- 각 분리 집합에 포함된 아이들의 사탕의 총 개수 = 각 훔칠 물건의 가치

예를 들어 예제 1번에서 분리 집합과 관련된 작업을 모두 수행하고 나면, 분리 집합은 4개가 존재하고 각각 포함하는 아이들의 수는 2, 4, 2, 2이며 사탕의 총 개수는 13, 26, 24, 33이 된다.

```text
          0   1   2	  3   4   5
0         0   0   0	  0   0   0
1(2, 13)  0   0   13  13  13  13
2(4, 26)  0   0   13  13  26  26
3(2, 24)  0   0   24  24  37  37
4(2, 33)  0   0   33  33  57  57
```

> 제출 결과 메모리를 상당히 많이 사용했다. 2차원 배열인 DP 배열 때문인 것으로 보이는데, 이를 최적화해 1차원 DP 배열을 사용할 수 있다.

위 예시를 기준으로 설명하면 지금은 연산 순서가 각 행에 대해 0, 1, 2, 3, 4, 5 열의 값을 순서대로 계산하며, i번째 행의 각 열의 값을 구하기 위해 i - 1번째 행의 값을 알아야 하기 때문에 2차원 배열을 사용한다.

이 연산 순서를 유지하면 i번째 행을 나타내는 1차원 배열 dp와 i - 1번째 행을 나타내는 1차원 배열 prev를 사용하여 메모리를 줄일 수 있겠지만, 매번 dp의 값을 prev에 복사해야 하므로 상대적으로 시간이 오래 걸릴 것이므로 이 방법은 제외한다.

그럼 연산 순서를 유지하지 않는다면? -> 열을 역순으로 접근한다면? -> 1차원 dp 배열 하나만으로도 풀 수 있다.

현재 이차원 배열을 기준으로 dp[i][j]를 구할 때 dp[i - 1]번째 행에서 필요한 값은 `열 인덱스가 j보다 작은 열의 값`이다.  
간단하게 예를 들면, 1차원 배열 dp 하나만으로 연산을 해서 2번째 행까지 구하는데 성공했다고 하자.

3번째 행에 대해 값을 구하는 과정은 다음과 같다.

- i: 5, 4, 3, 2, 1 순서로 탐색

dp[i] = Math.max(dp[i](2차원 배열로 따지면 dp[2][i]), 24 + dp[i - i행의 아이들의 수](2차원 배열로 따지면 dp[2][i]))

이에 더해 현재 행에 대응하는 분리 집합에 포함된 아이들의 수와 인덱스 i를 비교해 i가 아이들의 수보다 작아지면 그냥 그 값을 그대로 유지하면 되기 때문에 그보다 작은 인덱스에 대해선 연산을 할 필요가 없다.

---

`분리 집합 + DP 배낭 문제` 말고 `그래프 탐색 + DP 배낭 문제`로도 풀 수 있다.

DFS 또는 BFS로 아이들의 친구 관계를 탐색 -> 현재 아이가 받은 사탕의 개수를 다음 아이가 받은 사탕의 개수에 더하며 누적 & 아이들의 수도 누적 + 방문 처리 -> 현재 친구 관계에서 더이상 탐색할 친구가 없다면 아이의 수와 사탕의 개수를 저장하고, 아직 탐색하지 않은 다음 친구 관계 탐색.
