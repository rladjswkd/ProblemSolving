### DP

---

> 이 문제를 O(N)에 푸는 방법이 있다고 한다.

- https://www.acmicpc.net/problem/28039 참고

---

근우, 명우의 매 턴 최선의 전략 계산

근우

아래 중 최대값 선택

1. 남아있는 카드 중 왼쪽을 선택했을 때 + 그 이후 최선의 선택의 결과
2. 남아있는 카드 중 오른쪽을 선택했을 때 + 그 이후 최선의 선택의 결과

명우

근우가 왼쪽을 선택했을 때, 아래 중 최대값 선택

    1. 남아있는 카드 중 왼쪽을 선택했을 때 + 그 이후 최선의 선택의 결과
    2. 남아있는 카드 중 오른쪽을 선택했을 때 + 그 이후 최선의 선택의 결과

근우가 오른쪽을 선택했을 때, 아래 중 최대값 선택

    1. 남아있는 카드 중 왼쪽을 선택했을 때 + 그 이후 최선의 선택의 결과
    2. 남아있는 카드 중 오른쪽을 선택했을 때 + 그 이후 최선의 선택의 결과

$2^N$ → $최대 2^{1000} * 50(테스트케이스의 수)$

시간 초과

근우든 명우든 남아있는 카드에 대해 최선의 선택의 결과는 같다. → bottom up dp?

dp 배열 = 3차원 배열

- 1차원: 남아있는 카드 중 첫 번째 카드의 인덱스
- 2차원: 남아있는 카드 중 마지막 카드의 인덱스
- 3차원: 길이가 2인 배열로, 첫 번째 값은 남아있는 배열에 대해 먼저 선택하는 사람의 최대 점수, 두 번째 값은 나중에 선택하는 사람의 최대 점수

> 남아있는 카드란, 최소 하나의 카드를 포함하므로 dp[x][x][] 형태까지가 가능하며 이때 마지막 차원의 두 값이 모두 0일 수는 없다.

즉, 마지막 차원의 두 값이 모두 0이라면 해당 칸은 값이 설정되지 않은(계산되지 않은) 칸이거나 유효하지 않은 칸(dp[x][0][]과 같이 첫 번째 카드의 인덱스가 마지막 카드의 인덱스보다 큰 경우)이다.

유효하지 않은 칸에 접근하지 않도록 제어한다면 dp의 두 값이 모두 0인 경우는 아직 계산하지 않은 칸일 때 뿐이다.

반대로 말하면 dp의 두 값 중 하나라도 0이 아니라면 그 칸은 계산된 칸이다 → 해당 남아있는 카드에 대해 추가로 연산을 하지 않아도 된다.

> 2차원 배열을 dp로 사용할 수 있을 것 같다. 시도해보자.

dp[i][j]에 i번째 카드부터 j번째 카드에 대한 근우, 명우의 점수 중 큰 점수를 저장한다.

재귀 함수의 인자로 i번째 카드부터 j번째 카드까지의 총합을 전달한다.

현재 턴이 근우인지 명우인지에 따라 i번쨰 카드부터 j번째 카드까지의 총합 - dp[i][j]를 활용 할 지 아니면 dp[i][j]를 활용 할 지 정하면 된다.
