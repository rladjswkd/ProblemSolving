단순한 방법  
모든 공에 대해 자신을 제외한 나머지 공들과 색, 크기를 비교하기 → N^2 으로 시간초과

색이 같은 공끼리 모아 크기 순으로 정렬하고, 이분 탐색으로 현재 공보다 작은 공의 개수를 찾기  
공의 색은 최대 N개이므로, 이땐 이분 탐색이 별 효과가 없고 결국 N^2가 된다.

단순한 방법에서 중복을 제거하는 방법을 찾아봐야 한다.

예제 입력 1에서 `1 10`을 기준으로 탐색한 후 `3 15`를 기준으로 탐색할 때 다시 `1 10`과 비교하는 건 불필요하다.

> `3 15`를 기준으로 할 때, 15 미만의 모든 공의 크기의 합과 15 미만의 색이 3인 공의 크기의 합을 미리 알 수 있다면?

단순히 15 미만의 모든 공의 크기의 합 - 15 미만의 색이 3인 공의 크기의 합이 `3 15`인 공으로 잡을 수 있는 모든 공의 크기의 합이 된다.

`int[200000][2001]` 배열에 각 색깔 별 주어진 공들의 크기에 대한 누적합을 저장하고 `int[2001]`에 모든 공들의 크기에 대한 누적합을 저장하여 활용하려 했는데, `int[200000][2001]`만 해도 메모리 초과가 날 것이다.

> 입력을 크기 기준으로 오름차순 정렬하면 메모리 사용을 줄일 수 있어보인다.

정렬한 입력을 순회하면서 색깔만을 배열의 차원으로 활용하면 1차원 `int[200000]` 배열만으로도 충분하다.

모든 색깔의 공에 대해 현재 공보다 크기가 작은 공은 `int` 변수로 추적하면 된다.
