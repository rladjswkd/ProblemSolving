```
1
100 0 0 0 0 0 0 0 0 0 0
0 80 70 70 60 0 0 0 0 0 0
0 40 90 90 40 0 0 0 0 0 0
0 40 85 85 33 0 0 0 0 0 0
0 70 60 60 85 0 0 0 0 0 0
0 0 0 0 0 95 70 60 60 0 0
0 45 0 0 0 80 90 50 70 0 0
0 0 0 0 0 40 90 90 40 70 0
0 0 0 0 0 0 50 70 85 50 0
0 0 0 0 0 0 66 60 0 80 80
0 0 0 0 0 0 50 50 0 90 88
```

이런 문제는 보통 그리디처럼 무조건 아직 포지션을 정하지 않은 선수 중 가장 큰 능력치를 가진 선수를 고르는 것이 정답이 아니다.

그렇게 정답을 도출하려면 1부터 11까지의 포지션을 나열하는 모든 경우에 대해 각 경우에 나열된 포지션의 순서대로 선택할 수 있는 선수 중 가장 큰 능력치를 가진 선수를 선택해 그 능력치를 더한 값들 중 가장 큰 총합을 도출해야 한다. -> 11! \* (11 + 10 + 9 + ... + 1)

하지만 이 방식은 시간 초과가 분명하다.

> 제거할 수 있는 중복 연산이 있나?

있긴 하다.

위의 방식에서 `11 10 9 8 7 6 5 4 3 2 1`의 경우와 `11 10 9 8 7 6 5 4 3 1 2`의 경우는 11부터 3까지의 연산 결과를 공유한다.

하지만 이러한 중복을 제거하는 건 쉽지 않아보인다.

> 선수 별로 주어지는 포지션 별 능력치는 최대 5개이므로, 선수 한 명 당 5개의 포지션 중 하나를 선택하면 된다.

즉, 최대 $5^11$ 개의 경우를 확인하면 되는 거 아닌가?

포지션 별 지정 여부를 확인해 이미 지정된 포지션에는 현재 선수를 배치하는 걸 고려하지 않으면 연산을 더 줄일 수 있다.

만약 현재 선수가 뛸 수 있는 포지션 모두에 다른 선수를 배치했다면, 그 브랜치는 거기서 끊고 돌아간다.
