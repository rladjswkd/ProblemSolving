2 2 2

aazz
azaz
azza
zaaz
zaza
zzaa

일단 규완이의 사전에 있는 문자열의 개수는 (a개수 + z개수)! / a개수! / z개수!개다. => 이하 `문자열개수`

이 값보다 k가 크다면 -1을 출력한다.

aaazzz
aazazz
aazzaz
aazzza
azazza
azzaza
azzzaa

zaaazz
zaazaz
zaazza
zazaza
zazzaa
zzazaa
zzzaaa

a와 z의 개수가 같다면 k가 규완이의 사전에 있는 문자열의 개수의 절반보다 작거나 절반과 같다면 맨 앞 문자는 a, 그렇지 않다면 맨 앞 문자는 z

1 1
az
za

1 2
azz
zaz
zza

1 3
azzz
zazz
zzaz
zzza

2 1
aaz
aza
zaa

2 2
aazz
azaz
azza
zaaz
zaza
zzaa

2 3
aazzz
azazz
azzaz
azzza
zaazz
zazaz
zzaaz
zazza
zzaza
zzzaa

2 4
aazzzz
azazzz
azzazz
azzzaz
azzzza
zaazzz
zazazz
zazzaz
zazzza
zzaazz
zzazaz
zzazza
zzzaaz
zzzaza
zzzzaa

=> `문자열개수` 중 a로 시작하는 문자열과 z로 시작하는 문자열의 개수는 a의 개수와 z의 개수에 비례한다.

> k가 최대 10억이므로 k번째 숫자를 1번째부터 하나씩 구해가면 무조건 시간 초과가 발생할 것이다.

시작이 a인지 z인지 구분하여 나머지를 제거하고 다시 그 다음 문자에 대해 a인지 z인지 구분하여 나머지를 제거하는 식으로 풀면 될 것 같다.

예제 입력 4를 보자.

```
7 4 47
```

`문자열개수`는 11!/7!/4! = 330 개다.

여기서 a로 시작하는 문자는 330 / 11 \* 7 = 210개이고, z로 시작하는 문자는 330 / 11 \* 4 = 120개다.

문자열들이 알파벳 순으로 정렬되어있으므로 47번째는 `a`로 시작하는 문자열에 해당한다.

새로운 값들에 대해 위 과정을 반복한다.

`문자열개수`는 210개가 되었고, 이전에 a를 선택했으므로 a의 개수는 하나 빠진 6개, z의 개수는 그대로 4개가 된다. (참고. 당연히 210은 10! / 6! / 4!과 같다)

여기서 a로 시작하는 문자는 210 / 10 \* 6 = 126개이고, z로 시작하는 문자는 210 / 10 \* 4 = 84개다.

47번째는 현재 문자가 `a`인 문자열에 해당한다.

...

126 5 4

a로 시작하는 문자열 70개, z로 시작하는 문자열 56개

47번쨰는 현재 문자가 `a`인 문자열.

70 4 4

a로 시작하는 문자열 35개, z로 시작하는 문자열 35개

47번째는 현재 문자가 `z`인 문자열.

> 여기서 70 / 8은 정수가 아니다. double을 써야하나? 느린데..

두 숫자의 최대공약수를 구해 두 숫자에서 나눠버리면 4 4가 1 1이 되므로 70 / 2를 구해 정수를 얻을 수 있다.

다시 돌아가자.

35 4 3

a로 시작하는 문자열 20개, z로 시작하는 문자열 15개

직전 과정에서 z를 선택하며 그 앞의 a로 시작하는 문자열 35개를 현재 문자열보다 앞에 위치하는 문자열로 간주했다. 이를 반영해야 한다. 그 전까지는 고려한 모든 문자가 a였으므로 k번째 문자열보다 앞에 있는 걸로 무조건 간주할 수 있는 문자열들이 존재하지 않았다.

47 - 35 = 12.

12번째는 현재 문자가 `a`인 문자열.

20 3 3

a로 시작하는 문자열 10개, z로 시작하는 문자열 10개.

12번째는 현재 문자가 `z`인 문자열. => 12 - 10

10 3 2

a로 시작하는 문자열 6개, z로 시작하는 문자열 4개.

2번째는 현재 문자가 `a`인 문자열.

6 2 2

a로 시작하는 문자열 3개, z로 시작하는 문자열 3개.

2번째는 현재 문자가 `a`인 문자열

3 1 2

a로 시작하는 문자열 1개, z로 시작하는 문자열 2개.

2번째는 현재 문자가 `z`인 문자열 => 2 - 1

2 1 1

a로 시작하는 문자열 1개, z로 시작하는 문자열 1개.

1번째는 현재 문자가 `a`인 문자열

1 0 1

a로 시작하는 문자열 0개, z로 시작하는 문자열 1개.

1번째는 현재 문자가 `z`인 문자열 => 1 - 1

0 0 0

종료!

이를 종합하면 예제 입력 4의 출력값은 `aaazazaazaz`

이는 최대 200개의 문자를 선택하는 연산이므로, 시간 초과는 나지 않을 것으로 보인다.

---

> a의 개수가 100, z의 개수가 100이면 문자열개수는 200! / 100! / 100! 개인데, 결과값 자체도 그렇고 100!과 200! 모두 long으로도 표현할 수 없는 값이다.

BigInteger 활용? 아.. 그런데 일반적으로 알고리즘 문제에서 BigInteger와 같은 클래스를 사용하는 방식은 좋은 알고리즘이라고 말하기 어렵지 않나..

### BigInteger를 사용하지 않는 방법?

a를 깔아놓고, 양끝과 사이사이에 z를 끼워넣기 = 중복 조합. $_{a의개수+1}H_{z의개수}$ = $_{a의개수+z의개수+1-1}C_{z의개수}$ (참고. $_nH_r = _{n+r-1}C_r$)

> dp[i][j]로 i개의 a와 j개의 z로 만들 수 있는 문자열의 개수를 표현

dp[0][0] = 1  
dp[0][1] = 1C1 = 1  
dp[0][2] = 2C2 = 1  
dp[0][3] = 3C3 = 1

dp[1][0] = 1C0 = 1  
dp[1][1] = 2C1 = 2  
dp[1][2] = 3C2 = 3  
dp[1][3] = 4C3 = 4

dp[2][0] = 2C0 = 1  
dp[2][1] = 3C1 = 3  
dp[2][2] = 4C2 = 6  
dp[2][3] = 5C3 = 10

dp[3][0] = 3C0 = 1  
dp[3][1] = 4C1 = 4  
dp[3][2] = 5C2 = 10  
dp[3][3] = 6C3 = 20

> $dp[i][j] = dp[i][j - 1] * (i + j) / j$

dp[i][j]가 int로 표현할 수 있다 하더라도, 곱하기 연산에서 int 범위를 넘어서 오버플로가 날 수 있으므로 long 타입을 쓰자.

굳이 long[201][201]로 선언해서 파스칼 삼각형을 쓸 필요가 없어보일 정도로 간단한 연산이다.

> 알고리즘

1. 이런식으로 x개의 a와 y개의 z를 가지고 dp 배열을 채운다. 단, 10억이 넘어가면 10억을 저장한다. (k가 최대 10억이므로)
1. dp[x][y] 값보다 k가 크다면 -1을 반환한다. 그렇지 않다면 아래 내용을 반복한다.
   - dp[x - 1][y] >= k라면 현재 문자로 a를 선택하고 그렇지 않다면 z를 선택한다.
   - a를 선택한 경우 x를 x - 1로 업데이트한다.
   - z를 선택한 경우 z를 z - 1로 업데이트하고, k에서 dp[x - 1][y]를 뺀다.
