- BFS

456789 10

45 46 47 48 49 56 57 58 59 67 68 69 78 79 89 : 6C2 = 15

이미 방문한 숫자도 방문할 수 있어야 함
[예제 2] 132 -> 312 -> 321 -> 312

15^10 => 무조건 시간 초과 및 큐 메모리 초과

음.. 가장 큰 수와 두 번째로 큰 수만 다시 방문할 수 있게 해도 되지 않을까

- 정렬

각 숫자와 기존 인덱스를 저장해 숫자를 기준으로 내림차순 정렬.

정렬된 숫자들에 대해 앞에서부터 현재 인덱스와 기존 인덱스가 다르면 교환.

k회만 교환하고 종료.

현재 인덱스와 기존 인덱스가 달라서 교환할 때, 이후에 위치한 숫자들의 인덱스들의 기존 인덱스에 영향을 미칠 수 있다.

예를 들어 입력이 67135라면 가장 처음 교환할 때 6과 7을 교환한다.

이후 6도 원래대로라면 정렬 후 인덱스와 기존 인덱스가 다르지만 6과 7이 교환되며 6의 기존 인덱스가 정렬 후 인덱스와 같아지기 때문에 교환을 하지 않아야 한다. => 위의 방법으론 기존 인덱스를 업데이트할 O(1)짜리 방법이 없고, 이로 인해 문제가 생긴다.

그냥 어차피 숫자가 최대 7개이므로 순차탐색으로 현재 교환할 숫자의 인덱스를 찾자.

만약 모든 숫자를 다 교환하고도 k회 교환이 되지 않았다면 가장 마지막의(가장 작은) 두 숫자를 서로 교환하며 k회 채우기 => 이 과정에서 숫자의 길이가 줄어든다면 -1을 반환

> 위 정렬 방법의 문제

입력이 아래와 같을 때 8814를 출력한다.

```
1488 2
```

하지만 8841을 출력해야 정답이다.

같은 숫자가 여러 개라면 이 숫자들과 자리를 바꿀 숫자들을 모아 큰 수를 먼저 가장 왼쪽 자리에 넣고 그 다음 수를 그 다음 왼쪽 자리에 넣는 방식으로 하면 되겠지만.. 억지로 짜맞추는 방식같다.

- 다시 BFS

> 시간 초과가 맞나?

일단 가능한 큰 수를 찾는 거니까 교환 횟수가 k보다 작고 아직 주어진 숫자를 가지고 만들 수 있는 가장 큰 수에 도달하지 못했을 땐 교환 결과가 현재 값보다 클 때만 교환하면 시간을 줄일 수 있다.

이후 교환 횟수가 k보다 작다면(만들 수 있는 가장 큰 수엔 도달함이 보장된다.) k에 도달할 때까지 0이 아닌 가장 작은 수 두 개를 반복적으로 교환한다.

- 760000 1이 입력일 때 670000을 출력해야 한다.

이렇게 하면 시간을 줄일 수는 있어보이는데, 깔끔해보이지 않는다.

> X 자리의 숫자면서 첫 번째 자리를 제외하곤 모두 0이거나 한 자리 숫자면 무조건 -1 출력

> k 번째 교환에 대해 만들 수 있는 모든 숫자들 중 가장 큰 숫자만 뽑아 써도 될 것 같다?

예제 2번을 예로 들면, 주어진 수 132에 대해 교환 한 번으로 만들 수 있는 숫자들은 312, 231, 123이다.

이 중 가장 큰 312만 뽑아 사용하는 것이다.

312에 대해 교환 한 번으로 만들 수 있는 숫자들은 132, 213, 321이다.

다시 321을 뽑아 교환하면 231, 123, 312가 가능하다.

이 중 가장 큰 312를 뽑아 출력하면 된다.

> 같은 숫자가 여러 개면 그 중 두 숫자를 교환해 같은 값을 얻을 때도 교환 횟수가 1 줄어드네

> 위 방법으로는 아래 입력을 풀 수 없다.

```
4188 2
```

첫 번째 교환에서 8184를 선택하고 두 번째 교환에서 8814를 선택한다.

하지만 정답은 8841이다.

> 결국 그리디한 로직은 아예 제거해야 하며, 중복을 줄일 다른 방법을 찾아야 한다.

맨 위의 입력을 다시 살펴보자.

```
456789 10
```

45 46 47 48 49 56 57 58 59 67 68 69 78 79 89 : 6C2 = 15

첫 번째 교환에 45, 두 번째 교환에 78을 교환한 숫자와 첫 번째 교환에 78, 두 번째 교환에 45를 교환한 숫자는 같은 숫자다.

또한 순서대로 45, 46을 교환한 숫자와 46, 45를 교환한 숫자도 같다.

즉, 교환의 구성이 같다면 순서는 중요하지 않다.

같은 교환 횟수에 대해 결과가 같다면 큐에 추가하지 않는다.
