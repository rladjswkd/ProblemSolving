10 1 5 2 3

1: 1 5 2 3 10
2: 1 2 3 5 10
3: 1 2 3 5 10 -> 3 출력

숫자 3의 위치는 기존 위치 - (i - 1)이다.

1. 우선순위 큐를 사용해 i번째로 큰 숫자 `v`를 찾는다.
1. 주어진 입력에서 해당 숫자의 인덱스 `idx`를 확인하고 직전 버블 소트 적용 결과 `v`가 위치한 인덱스인 idx - (i - 1)과 이번 버블 소트 적용 결과 `v`가 위치해야 하는 인덱스 n - (i - 1)을 비교한다.
   - 두 값이 같다면 `v`는 애초에 정렬된 상태.

---

숫자 하나의 정렬 상태가 아니라 가장 처음으로 전체 배열이 정렬될 때의 i를 출력하는 문제다.

가장 긴 증가하는 부분 수열의 길이를 찾아 이를 전체 수열의 길이에서 빼면 된다!!!

### LIS

DP, 이분 탐색. 범위가 크면 이분 탐색으로만 가능하다.

배열 내에 같은 숫자가 있을 수 있으므로, upper bound 방식을 사용하자.

기존 LIS는 lower bound를 사용한다.("증가하는 부분 수열"이지 "감소하지 않는 부분 수열"이 아니므로)

땡!

다음과 같은 입력을 생각해보자.

```
8
2 3 4 5 1 6 7 8
```

이 코드는 2, 3, 4, 5를 뒤로 옮겨야 정렬되므로 5를 출력해야 한다.

`첫번째시도.md` 방식의 코드로는 2, 3, 4, 5, 6, 7, 8이 LIS가 되고 이 길이가 7이므로 8 - 7 + 1 = 2를 출력한다.

LIS 방법을 사용하되, 새로 추가할 숫자가 배열의 뒤에 새로 추가되는 것이 아니라 이미 값이 존재하는 인덱스를 대체하는 상황이라면 그 뒤의 숫자들을 없다고 간주하자.

2 5 8 3 9 10이 입력으로 들어오면 가장 처음엔 LIS가 2 5 8일 것이다.

이후 3이 들어가면 5가 3으로 대체되고, 우리는 LIS를 2 3 8이 아닌 2 3으로 바꿔야 한다. (8은 무조건 버블 정렬 시 3 뒤로 넘어가야 하는 숫자이므로, changed를 true로 만든다.)

> 이렇게 하면 기존에 통과하던 예제에서 문제가 생길까?

10 1 5 2 3이 입력으로 들어왔을 때, 마지막에 LIS에 담긴 값은 1 2 3이 되고, 그 길이는 3이 된다.

문제가 없다.

땡!

다음과 같은 입력을 생각해보자.

```
8
4 3 2 1 8 7 6 5
```

`두번째시도.md`의 방식으로는 8 - 2 + 1 = 7을 출력한다.

하지만 실제 정렬 과정은 다음과 같다.

i = 1 → 3 2 1 4 7 6 5 8
i = 2 → 2 1 3 4 6 5 7 8
i = 3 → 1 2 3 4 5 6 7 8
i = 4 → 1 2 3 4 5 6 7 8

따라서 정답은 4다.

---

자신보다 앞에 있는 자신보다 큰 수의 개수가 정렬 과정에서의 자신과 다른 수 사이의 스왑 횟수가 된다.

모든 숫자에 대해 이 값을 구해 그 중 가장 큰 값 + 1을 반환하면 된다.

> 자신보다 앞에 있는 수들 중 자신보다 큰 수의 개수를 어떻게 구할까?

일단 모든 숫자에 대해 이 값을 구해야 하므로, 이 연산의 개수를 x라 할 때 500000 \* x가 시간 내에 수행되어야 한다.

즉, x는 log(500000) 정도의 연산이어야 한다.

> 자신과 다른 수 사이의 스왑 횟수를 구하는 것이므로 다음과 같이 구할 수 있다.

값과 기존 인덱스를 저장한 후 값을 기준으로 오름차순 정렬을 한다. 정렬 후 인덱스가 기존 인덱스보다 작다면 자신보다 앞에 있던 자신보다 큰 수가 뒤로 넘어간 것이므로 두 인덱스 사이의 차가 스왑 횟수가 된다.

또는 그냥 값만을 저장한 후 정렬을 한다. 정렬 후 기존 배열을 순회하며 각 값을 이용해 정렬된 배열에 대해 이분 탐색(upper bound)을 적용하여 위와 같이 기존 인덱스와 정렬 후 인덱스를 활용하면 된다.

첫 번째 방법은 정렬에 nlogn, 최대 스왑 횟수를 찾는데 n 개의 연산이 필요하므로, nlogn + n 의 연산이 필요하다.

두 번째 방법은 정렬에 nlogn, 최대 스왑 횟수를 찾는데 nlogn 개의 연산이 필요하므로, 2nlogn의 연산이 필요하다.

둘 다 시간 내에 통과는 가능하다.

> 같은 값이 여러 개 있다면, 정렬 후에도 기존의 순서를 유지하는 게 보장이 되어야 할 것 같다.
