N개의 점으로 만들 수 있는 가장 짧은 벡터를 고르고, 그 다음엔 N - 2개의 점으로 만들 수 있는 가장 짧은 벡터를 고르는 방식으로 반복하여 N / 2 개의 벡터를 선택하는 게 답일까?

아니다.

다음과 같이 일직선 상에 점 4개가 있다고 해보자.

```
1                  2  3                  4
```

위 방법대로 고르면 (2, 3), (1, 4)가 선택될 것이다.

이보단 (1, 2), (3, 4)를 선택해야 더 작은 벡터 길이의 총합을 구할 수 있다.

> 브루트포스?

점이 최대 20개이므로, 브루트포스로 구하면 테스트케이스 하나당 필요한 연산 횟수는 다음과 같다.

$_{20}C_2 \ * \ _{18}C_2 \ * ... * \ _2C_2 = 2.37588E+15$. 테스트케이스 하나만으로도 무조건 시간 초과

> 중복을 제거해야 한다.

(12, 34)와 (34, 12)는 같은 선택이므로 두 번 확인할 필요가 없다.

---

### 아니!!!! "벡터 합"의 길이네!!!! 위의 내용은 무시하자!!!!

- "P에 속하는 모든 점은 한 번씩 쓰여야 한다."는 말은 한 번은 꼭 쓰여야 한다는 말인가?

만약 그렇다면, 최대 20개의 점으로 만들 수 있는 모든 가능한 벡터 10개를 다 더했을 때의 크기 중 최소값을 선택해야 하네

이때 20개의 점을 나열한 20!개의 수열은 다음을 나타낸다.

```
벡터1의 시작점, 벡터1의 끝점, 벡터2의 시작점, 벡터2의 끝점, ..., 벡터10의 시작점, 벡터10의 끝점
```

단, 10개의 벡터들의 순서는 중요하지 않다.

따라서 벡터를 만드는 데 20!를 10!로 나눈 $_{20}P_{10}$ 만큼의 연산이 필요하다.

> $_{20}P_{10}$ 개의 연산만으로도 시간 초과다.

그리고 10개의 벡터들의 순서로 인한 중복을 제거하는 부분을 코드로 어떻게 구현할지 모르겠다.

그냥 주어진 점 20개에 대해 dfs 실행..??

첫 번째 벡터 (1, 2), (1, 3), (1, 4), (1, 5), ... , (1, 20): 19개의 경우
두 번쨰 벡터 - 첫 번째 벡터가 (1, 2)일 때 (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), ... , (3, 20): 17개의 경우
...

19 \* 17 \* 15 \* ... \* 1 \* 2^10(10개의 벡터마다 벡터의 시작과 끝이 바뀌는 경우에 대한 고려)

그런데 이거 계산하면 결국 그 값이 $_{20}P_{10}$ 과 같다.

---

<!-- 벡터를 어떻게 더하든 결국엔 시작과 끝 점을 잇는 벡터가 된다. → 어떤 두 점을 기준으로 잡고 나머지 중 두 점을 골라 이 두 벡터를 더했을 때의 최솟값을 찾으면 된다.

> 브루트포스?

테스트케이스 하나 당 점이 최대 20개이므로, 이 중 두 벡터를 만들 점 4개를 고르기 위한 연산 횟수는 $_{20}C_4 = 4845$ 번이다.

벡터 합 => 두 벡터 중 하나를 나머지 벡터의 끝 점에서 시작하도록 평행 이동하여, 나머지 벡터의 시작과 평행이동한 벡터의 끝점을 잇는 벡터를 생성

따라서 다음과 같이 풀 수 있다.

1. 점들 중 네 개를 선택 → 벡터 A, B
1. B의 시작점이 A의 끝점이 되도록 벡터 B를 평행 이동
1. A의 시작점과 B의 끝점을 잇는 선분의 길이를 측정해 가장 작은 값을 출력

단, 선택한 점들로 벡터 A와 B를 만들 때 가능한 $4! = 24$개의 쌍을 고려해야 한다.
선택한 네 개의 점을 a, b, c, d라 할때 순서대로 벡터 A의 시작점, 벡터 A의 끝점, 벡터 B의 시작점, 벡터 B의 끝점이라고 하면 가능한 경우는 $4!$개다.

이를 종합해 그냥 애초에 점 4개를 순서를 고려해 고르면 $_{20}P_4 = 116280$ 개의 연산이 필요하다. -->

두 벡터를 더할 때 한 벡터의 시작점을 나머지 벡터의 끝점과 일치시키도록 평행 이동을 해야하므로 단순히 주어진 점들 중 네 개를 선택하면 안된다.

> 평행이동을 하지 않아도 된다.

모든 벡터의 x 성분만 더한 값 $x_A$와 y 성분만 더한 값 $y_A$를 가지고 $\sqrt{x_A^2 + y_A^2}$을 구하면 된다.

물론 성분별로 방향을 고려해 양수, 음수 처리를 해줘야 한다.

> 단순히 성분을 더하는 것에 기반하여 생각하면 $_{20}P_{10}$을 구하지 않아도 된다.

그냥 주어진 N개의 점 중에 N / 2개의 x 성분은 $x_A$에 더하고 나머지 N / 2개의 x 성분은 $x_A$에 빼면 된다. y 성분도 마찬가지로 처리하면 된다.

최대 $_{20}C_{10}$ 개의 연산이 필요하다.

쉽게 말하면 점이 (x1, y1), (x2, y2) 두 개가 있을 때, 벡터는 (x2 - x1, y2 - y1) 또는 (x1 - x2, y1 - y2)다.

벡터 하나 당 점이 두 개고 두 점중 하나는 부호 그대로 성분값이 더해지며 나머지 하나는 부호가 뒤집힌 채 성분값이 더해진다(빼기).

> 더할 값 N / 2개와 뺄 값 N / 2개를 정하는 방법

1. 더할 값으로 정한 숫자의 개수와 뺼 값으로 정한 숫자의 개수를 인자로 받는 재귀 함수 내에서 두 개의 if문으로 재귀 호출을 하는 방법

   - 더할 값으로 정한 숫자의 개수 < N / 2라면 현재 점을 더하고 재귀 호출
   - 뺄 값으로 정한 숫자의 개수 < N / 2라면 현재 점을 빼고 재귀 호출

1. 비트마스킹을 사용해 더할 값에 해당하는 인덱스만 N / 2개를 취하고 모두 더한 다음 마스킹되지 않은 비트에 해당하는 인덱스를 모조리 빼는 방법
