1 -> 우선순위 큐에서 제거한 숫자 개수: 0, 우선순위 큐 내의 숫자 개수: 1 -> 총 1개에 대해 중앙값: 1번째 -> 우선순위 큐에서 1 제거해 출력

5, 4 -> 우선순위 큐에서 제거한 숫자 개수: 1, 우선순위 큐 내의 숫자 개수: 2 -> 총 3개에 대해 중앙값: 2번째 -> 우선순위 큐에서 4 제거해 출력

5, 3, 2 -> 우선순위 큐에서 제거한 숫자 개수: 2, 우선순위 큐 내의 숫자 개수: 3 -> 총 5개에 대해 중앙값: 3번째 -> 우선순위 큐에서 2 제거해 출력(?)

이 방법은 못쓴다.

게다가, 두 번째에서 4가 빠졌는데 이후 숫자 7까지 총 1 2 3 4 5 6 7이 들어온다면 다시 4를 출력해야 한다.

아! 아니다. 제거한 걸 다른 우선순위 큐에 담으면 된다.

```
1 5 4 3 2
```

1 → 1
5, 4 → 이전 중위값 1, 그 이후 들어온 값 5, 4 → 4
5, 3, 2 → 이전 중위값 4, 그 이후 들어온 값 3, 2 → 이전 중위값의 위치가 2번째 값이고, 새로 들어온 두 값이 이보다 작으므로 4가 4번째 값이 되고 숫자는 총 5개이므로 3번째 값이 중위값이 된다.

앞의 우선순위 큐는 최소 우선순위 큐인 `majorPQ`, 뒤의 우선순위 큐는 최대 우선순위 큐인 `minorPQ`를 사용한다.

1. 첫 번째 숫자를 첫 번째 중위값으로 설정한다.
1. 이후에 들어오는 값이 중위값을 기준으로 상대적으로 크거나 같으면 `majorPQ`에 추가하고, 작으면 `minorPQ`에 넣는다. → 반복
1. 현재 들어온 숫자가 홀수 번째 숫자라면 새로운 중위값을 찾는다.
   - `majorPQ`와 `minorPQ`의 크기가 같아지도록 크기가 작은 우선순위 큐에 기존 중위값, 크기가 큰 우선순위 큐의 원소들을 추가한다.
   - 두 우선순위 큐의 크기가 같아지는 순간 크기가 큰 우선순위 큐에서 뺀 숫자가 새로운 중위값이 된다.

> 중위값을 기준으로 현재 들어온 값이 동일할 때 `minorPQ`에 추가하면 뭐가 달라질까?

달라지는 건 없다.

> `minorPQ`를 선언할 때, Collections.reverseOrder()나 (a, b) -> b - a와 같이 역순 Comparator를 사용하지 말고 최소 우선순위 큐를 유지하되, 추가하는 값을 음수로 만들어서 사용하면 더 빠르다.
