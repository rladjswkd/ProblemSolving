1. 입력을 읽으며 X의 개수 `xCount`를 저장한다
2. S에서 출발해 BFS를 실행한다.
   - 이때 방문 처리는 3차원 boolean 배열로 수행한다 → boolean[행인덱스][열인덱스][방문한X의개수]
   - 또는 byte[행인덱스][열인덱스]와 비트마스킹을 활용하여 수행한다.
3. `xCount` 개의 X 칸을 방문한 뒤 E 위치에 방문할 때까지 계속 BFS를 실행한다.

> 문제가 있다.

```
5 5
#####
ES..#
#X..#
#X.X#
#####
```

위와 같은 입력에 대해 정답은 9를 출력해야 한다.  
S → (2, 1) → (3, 1) → (3, 3) → (1, 0)

하지만 위와 같은 방식(단순히 방문한 X 칸의 개수를 세는 방식)으로는 아래와 같은 경로를 방문하고 5를 출력한다.
S → (2, 1) → (3, 1) → (2, 1) → (1, 0)

이전에 들른 X인지 아직 들르지 않은 X인지를 구분하지 못해 발생하는 문제다.

---

1. 입력을 읽으며 X의 개수 `xCount`를 저장한다.
1. S에서 가장 가까운 X를 BFS로 찾는다.
1. 그 X까지의 거리를 결괏값에 더하고 해당 X칸의 값을 .으로 바꿔준다.
1. 현재 위치(원래 S에서 가장 가까운 X가 있던 칸)에서 다시 BFS로 가장 가까운 X를 찾는다.
1. 다시 직전 위치에서 현재 위치까지의 거리를 결괎값에 더하고 해당 X칸의 값을 .으로 바꿔준다.
1. 이 과정을 xCount번 반복한다.
1. 이후 마지막 X이던 칸에서 E까지의 거리를 BFS로 측정한다.

> 이 또한 문제가 있다.

```
#######
#XXSXXE
#######
```

위와 같은 입력을 보자. (2, 1)과 (4, 1)은 모두 S로부터 거리가 같다.

하지만 반드시 (2, 1)이 선택되어야 한다.

```
#########
#X..XSXXE
#########
```

위와 같은 입력을 보자. 현재 (4, 1)을 방문한 상태라고 가정하자.

이후 가까운 X칸을 먼저 찾으면 (6, 1)을 방문하게 된다.

하지만 우리는 (1, 1)을 방문해야만 한다.

---

> !!!!!!!

그냥 첫 번째 로직에서 이미 방문한 X를 .로 바꿔주면 되지 않나??

이렇게 하면 BFS 실행 도중 미리 방문하게 되지만 실제로는 나중에 방문해야 하는 X칸일 때 문제가 생긴다.

위의 입력을 다시 보자.

```
#######
#XXSXXE
#######
```

(5, 1), (6, 1)의 X는 실제 S에서 출발해 E에 도달하는 경로대로 거치기 전에 BFS에 의해 미리 .로 바뀔 것이다.

---

> !!!!!!!

X가 최대 5개이므로, 모든 X의 좌표를 저장하고, 이들의 인덱스를 활용해 특정 인덱스의 X 칸을 방문하면 해당 칸에 대해 방문 처리를 하여 각 경로가 어떤 X를 방문했는지 확인할 수 있다.
