> 문제에 주어진 첫 번째 예시

3 2 5 4 1은 안되나? 안된다. "학생들에게서 자신보다 뒤에 서있으면서 더 작은 번호의 카드를 가진 학생들의 명단을 하나도 빠짐없이 모두 받았다."

(2, 5)에 대한 순서쌍이 없기 때문에 안된다.

1 2 5  
2  
3 4 5  
4 5  
5

depth

1 2  
2 0  
3 2  
4 1  
5 0

depth가 같다면 순서상 앞에 있는 것이 더 작은 숫자.

순서상 뒤에 있는 것이 더 작다면 무조건 순서상 앞에 있는 같은 depth를 가진 숫자에는 depth가 1 추가되어야 한다.

> 문제에 주어진 두 번째 예시

1 2 3 5  
2 5  
3 4 5  
4  
5

depth

1 3  
2 1  
3 2  
4 0  
5 0

올바른 입력이라 가정하고 위상 정렬을 실행하면?

4 → 1  
5 → 2  
2 → 3  
3 → 4  
1 → 5

5 3 4 1 2

정상 실행된다. 위상 정렬 알고리즘 자체로 거르진 못하고 올바른 입력이 아님을 찾아내야 한다.

자신보다 앞에 있는 자신보다 큰 숫자들의 개수

1 2 3 4 5
0 1 1 1 3

depth가 0인 숫자들을 먼저 확인할 때 4가 첫번째로 나오는데, 위치가 4이고 숫자가 1인데도 불구하고 자신보다 앞에 있는 자신보다 큰 숫자들의 개수가 3이 아니라서 탈락

> 첫 번째 예시에 대해 위 방법이 맞나 검증해보자.

1 2 5  
2  
3 4 5  
4 5  
5

depth

1 2  
2 0  
3 2  
4 1  
5 0

1 2 3 4 5
0 1 0 1 3

2 → 숫자 1, 위치 2. 자신보다 앞에 있는 자신보다 큰 숫자의 개수가 1이므로 통과
5 → 숫자 2, 위치 5. 자신보다 앞에 있는 자신보다 큰 숫자의 개수가 3이므로 통과
1 → 숫자 3, 위치 1. ?
4 → 숫자 4, 위치 4. ?

---

1 2 3 4 5
2 0 2 1 0

1: 남은 것들 중 앞에서 2번째 [1, 2, 3, 4, 5] → 3
2: 남은 것들 중 앞에서 0번째 [1, 2, 4, 5] → 1
3: 남은 것들 중 앞에서 2번째 [2, 4, 5] → 5
4: 남은 것들 중 앞에서 1번째 [2, 4] → 4
5: 남은 것들 중 앞에서 0번째 [2] → 2

1 2 3 4 5
3 1 2 0 0

1: 남은 것들 중 앞에서 3번째 [1, 2, 3, 4, 5] → 4
2: 남은 것들 중 앞에서 1번째 [1, 2, 3, 5] → 2
3: 남은 것들 중 앞에서 2번째 [1, 3, 5] → 5
4: 남은 것들 중 앞에서 0번째 [1, 3] → 1
5: 남은 것들 중 앞에서 0번째 [3] → 3

위와 같이 순서를 정한 다음에 모든 순서쌍에 대해 순서가 성립하는지 확인하고, 성립하지 않으면 -1, 성립하면 정한 순서를 출력하면 된다.

그런데, "남은 것 중 앞에서 x번째 수를 추출하는 과정"을 어떻게 구현할까

덱을 두 개를 써서 하든 링크드 리스트를 쓰든 뭘 하든 최악의 입력에 대해 시간 초과가 날 것 같다..

---

1. 초기 순서를 그냥 1, 2, 3, ... N과 같이 오름차순으로 둔다.
1. 순서쌍 u, v가 주어지면, 위의 순서에서 u 번째 값은 +1, v 번째 값은 -1을 한다.
1. 모든 순서쌍을 확인할 때까지 반복한다.
1. 결과 순서가 유효한지 확인한다.(동일한 숫자가 여러 번 반복되지 않는지)
