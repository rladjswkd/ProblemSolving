동전의 개수에 제한이 있다.

x원을 만들기 위해 사용한 동전의 개수를 추적해야 한다.

```
		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
0		1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0
```

10원짜리 동전으로 10, 20원을 만들 수 있다:

```
		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
0		1	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0	0

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
10		1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0	1
```

5원짜리 동전으로 5, 10, 15원을 만들 수 있다:

5원짜리 동전에 대해 20원부터 역순으로 `이전 동전까지의 dp배열에 대해` [만들 금액 - 현재 동전의 값]을 인덱스로 하는 dp값을 현재 만들 금액에 더해준다.

```
		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
0		1	0	0	0	0	0	0	0	0	0	1	0	0	0	0	0	0	0	0	0	1

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
5		1	0	0	0	0	1	0	0	0	0	1	0	0	0	0	1	0	0	0	0	1

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
10		1	0	0	0	0	1	0	0	0	0	2	0	0	0	0	1	0	0	0	0	2

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
15		1	0	0	0	0	1	0	0	0	0	2	0	0	0	0	2	0	0	0	0	2
```

1원짜리 동전으로 1, 2, 3, 4, 5원을 만들 수 있다:

```
		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
0		1	0	0	0	0	1	0	0	0	0	2	0	0	0	0	2	0	0	0	0	2

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
1		1	1	0	0	0	1	1	0	0	0	2	2	0	0	0	2	2	0	0	0	2

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
2		1	1	1	0	0	1	1	1	0	0	2	2	2	0	0	2	2	2	0	0	2

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
3		1	1	1	1	0	1	1	1	1	0	2	2	2	2	0	2	2	2	2	0	2

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
4		1	1	1	1	1	1	1	1	1	1	2	2	2	2	2	2	2	2	2	2	2

		0	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17	18	19	20
5		1	1	1	1	1	2	1	1	1	1	3	2	2	2	2	4	2	2	2	2	4
```

```java
import java.io.IOException;

public class Main {
	private static int t, k;
	private static int[] values, counts;

	private static int read() throws IOException {
		int n = System.in.read() & 15, c;

		while (48 <= (c = System.in.read()) && c <= 57)
			n = (n << 3) + (n << 1) + (c & 15);
		return n;
	}

	public static void main(String[] args) throws IOException {
		int[] dp, prev, swap;
		int value, current;

		t = read();
		k = read();
		values = new int[k];
		counts = new int[k];
		for (int i = 0; i < k; i++) {
			values[i] = read();
			counts[i] = read();
		}
		dp = new int[t + 1];
		prev = new int[t + 1];
		dp[0] = prev[0] = 1;
		for (int coin = 0; coin < k; coin++) {
			swap = prev;
			prev = dp;
			dp = swap;
			value = values[coin];
			for (int idx = 1; idx <= t; idx++) {
				dp[idx] = prev[idx];
				for (int cnt = 1; cnt <= counts[coin]; cnt++)
					if ((current = value * cnt) <= idx)
						dp[idx] += prev[idx - current];
			}
		}
		System.out.println(dp[t]);
	}
}
```

> T = 10000, k = 100, p = 1, n = 1000인 입력에 대해 시간 초과가 날 것 같다.

문제 조건에서 결과값은 $2^{31} - 1$을 초과하지 않는다 했으므로 시간 내에 풀 수는 있을 것 같다.

제출해보니 풀린다.
