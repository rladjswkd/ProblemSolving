BFS

A와 B 물통의 물의 양을 가지고 방문 체크를 한다.

여기까지가 첫번째시도

> boolean[100000][100000] = 100억 바이트

메모리 무조건 터진다.

[A의 현재 용량 * 1000000 + B의 현재 용량]을 key로 하여 HashSet을 사용하자.

여기까지가 두번째시도

> a와 b를 나눠서 생각하지 말고, 현재 소유한 물의 총량을 기준으로 생각해보자.

물이 w만큼 있을 때 이를 a와 b에 분배하는 방법을 생각해보자.

- w <= a
  - w <= b → (w, 0), (0, w)
  - w > b → (w, 0), (w - b, b)
- w > a
  - w <= b → (a, w - a), (0, w)
  - w > b → (a, w - a), (w - b, b)

단, w <= a + b다.

이 방식으로는 방문 확인을 boolean[200001] 배열로 처리할 수 있다.

> 위와 같이 물을 분배하는 것은 사실상 "물통 x의 물을 물통 y에 붓는 연산"을 수행하는 것이다.

연산의 수행 횟수를 이전 방식들처럼 수행하지 말고 큐의 원소에 추가하자.

물을 추가하거나 버리는 연산만 한 경우엔 연산 수행 횟수를 1 증가시키고, 재분배까지 한 원소는 연산 수행 횟수를 2 증가시키면 된다.

> 이를 위해선 deque를 써야 한다.

A 물통에 물 채우기, B 물통에 물 채우기, A 물통 비우기, B 물통 비우기만 수행했을 땐 addFirst.

그 결과에 대해 재분배를 했을 땐 addLast로 추가한다.

일단 틀림.

> 두 물병 모두 물이 들어있지만 꽉 차있진 않은 그런 상태는 존재할 수 없다.

결국 둘 다 꽉 차있거나 하나는 비어있거나
