단순한 방법
모든 아이들을 앞, 뒤로 보내는 경우를 다 확인한다. → 무조건 시간 초과

가장 긴 증가하는 부분 수열 LIS

```
5
5 2 4 1 3
```

위 입력에서 LIS는 2 4 또는 2 3이다.

2 3을 기준으로 LIS를 구성하는 숫자들은 고정시키고, 나머지 5, 4, 1을 적절한 순서와 위치로 이동시키면 된다.

> 2 4면 안된다.

2, 4를 고정시키면(이동시키지 않으면) 그 사이에 3을 위치시킬 방법이 없기 때문이다.

따라서 우리는 LIS가 아닌 가장 긴 `연속하며` 증가하는 부분 수열을 찾아야 한다.

dp?

크기가 n + 1인 1차원 int 배열 `dp`를 선언한다.

이 배열의 i번째 값은 숫자 i까지의 가장 긴 연속하며 증가하는 부분 수열을 나타낸다.

5 2 4 1 3

5 → dp[5] = dp[4] + 1 = 1
2 → dp[2] = dp[1] + 1 = 1
4 → dp[4] = dp[3] + 1 = 1
1 → dp[1] = dp[0] + 1 = 1
3 → dp[3] = dp[2] + 1 = 2

이 과정에서 가장 큰 값이 2이므로, 5 - 2 = 3을 출력한다.
