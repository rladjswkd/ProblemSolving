### 첫 번째 아이디어(DFS)

1. 그래프를 생성한다.

   - 상위 노드는 중간 부품, 하위 노드들은 해당 중간 부품을 만들기 위해 필요한 기본 부품 또는 중간 부품이다.
   - 동일한 기본 부품 또는 중간 부품이 여러 개 필요하다면 여러 개의 동일한 자식 노드를 갖게 한다.

1. 기본 부품을 식별한다.

   - X로 들어오지 않은 부품들이 기본 부품이다.

1. 기본 부품의 수를 크기로 갖는 배열을 N개 생성하고, 모두 null로 초기화한다.

1. 기본 부품들에 대해서만 배열을 초기화하고, 기본 부품 자신을 나타내는 인덱스의 값만 1로 업데이트한다.

1. 그래프를 탐색하며 현재 중간 부품을 인덱스로 하는 배열이 null이 아니면 반환하고, null이라면 자신의 자식 노드(부품)들을 순회하며 자식 노드들을 만드는데 필요한 기본 부품들의 수를 배열에서 가져와 모두 더해 현재 중간 부품을 만드는데 필요한 기본 부품을 나타내는 배열을 생성한다.

> 기본 부품 번호와 기본 부품 배열 내의 인덱스를 연결하는 mapper를 활용해야 한다.

### 두 번째 아이디어(BFS)

1. 그래프 생성
1. 기본 부품 식별
1. HashMap을 쓰든 위와 같이 mapper 배열을 쓰든, 기본 부품의 개수만큼의 크기를 갖는 자료 구조를 생성
1. 완제품 번호부터 시작해 BFS 실행
1. 다음 부품이 기본 부품이라면 큐에 추가하지 않고 그냥 자료 구조에서 해당 기본 부품을 나타내는 값을 증가
   - 증가시킬 값은 BFS 실행 과정에서 추적한다.
   - 예를 들어 완제품이 4고 기본 부품이 1일 때 4 3 5, 3 2 6, 2 1 3 이 입력이라면 큐에 3을 추가할 땐 필요한 개수인 5 \* 6을 함께 저장하고, 2를 저장할 땐 30 \* 3을 함께 저장한다. 이후 기본 부품인 1에 대해선 90 \* 3을 counter에 더한다.

> 부품의 개수가 많아야 100개니까 그냥 mapper 안써도 될 것 같다. 3번은 제거하고 부품의 개수를 크기로 갖는 counter에 필요한 기본 부품의 개수를 저장하고(중간 부품이면 그냥 0으로 둔다), 마지막에 그냥 부품의 개수만큼 반복문을 돌면서 해당 부품이 기본 부품일 때 출력 문자열에 추가하는 방식을 사용하자.

> 메모리 초과. 채점 중일 때 퍼센티지가 올라가는 빠르기를 보면, 메모리 초과가 나지 않아도 시간 초과가 날 것 같았다.

아무래도 이미 확인한 부품을 반복적으로 다시 확인하는 것이 문제라고 생각한다.

---

### 기본 부품부터 시작해서 거슬러 올라가는 방식

기본 부품, 기본 부품을 필요로 하는 중간 부품들, 그 중간 부품들을 필요로 하는 중간 부품들, ...

이 순서로 거슬러 올라가 완제품을 만들면 중복으로 연산하지 않아도 된다.

하나의 부품씩 DFS 방식으로 거슬러 올라가면 중복으로 탐색하는 루트가 발생할 수 밖에 없으므로 하나의 루트를 한 번만 탐색하도록 한다. → 위상 정렬이네?
